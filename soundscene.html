
<!DOCTYPE HTML>
<html>
	<head>

		<link rel="stylesheet" type="text/css" href="soundscene.css"/>
		<script src="js/jquery-1.11.0.min.js"></script>
		<script src="js/jquery-ui-1.10.4.custom.min.js"></script>
		<script src='js/spectrum.js'></script>
		<script src="js/ColorWheel.js"></script>
		<link rel='stylesheet' href='spectrum.css' />
		<link rel='stylesheet' href='bootstrap.css'>
		<link rel='stylesheet' href='jquery-ui-1.10.4.custom.min.css'>
		<script type="text/javascript">
			ColorMode = {
				MONOCHROME: 0,
				TWOTONE: 1,
				THREETONE: 2,
				GRADIENT: 3,
				RANDOM: 4
			};

			ShapeMode = {
				CIRCLE: 0,
				SQUARE: 1,
				SKEW: 2
			};

			GridMode = {
				RIGID: 0,
				CONCENTRIC: 1,
				RANDOM: 2,
				SPIRAL: 3,
				REVERSESPIRAL: 4,
				BUTTERFLY:5,
				ASTROID:6,
				EPICYCLOID:7,
				REVERSEEPIC:8,
				HYPOTROCHOID: 9,
			};
			
			DrawMode = {
				PEN:0,
				FILTER:1,
				NONE:2
			};

			var audioContext;
			var audioSource;
			var analyser;
			var waveshaper;
			var wavedistort;
			var gainnode;

			var freqDomain;
			var timeDomain;
			var canvas;
			var ctxt;
			var GRID_WIDTH = 32;
			var GRID_HEIGHT = 32;
			var SAMPLE_MAX = 256;
			var WIDTH = window.innerWidth;
			var HEIGHT =window.innerHeight * 0.95;
			var lastAmps;
			var frame = 0;
			var colormode = ColorMode.THREETONE;
			var shapemode = ShapeMode.CIRCLE;
			var gridmode = GridMode.SPIRAL;
			var drawmode = 2;
			var interp = 0;
			var filterShapes = []; 
			var filters = [];
			var oscillators = [];
			var reversed = false;
			var whiteNoise;
			var deletedFilter = false;
	
			var mousedownx;
			var mousedowny;
				
			var sceneDisplayed = false;			
			var drawing = false;
			var drawingFilter = false;
			var noiseLines = [];	

			var color1 = "#7355d7";
			var color2 = "#ffff00";
			var color3 = "#00ff00"
			var cwheel;
			var spacing = 1; // number between 0.1 and 2
			var framespeed = 1; // rate at which the frames are updated
			var logged = false;
	
			function init() {
				canvas = document.getElementById('canvas'); 
				ctxt = canvas.getContext('2d');	
				canvas.width = WIDTH;
				canvas.height = HEIGHT;
				$("#colorwheel").hide();
				console.log('width = ' + WIDTH + 'height = ' + HEIGHT);
				$('#controls').hide();
				$('#canvas').hide();
				$('#menu').hide();
				$('#backBtn').hide();

				$("#wavedistortion").slider({max:4, min:0, slide:wavedistortionChange, step:0.2});
				$("#playbackspeed").slider({min:0, max:2, slide:playbackspeedChange, step: 0.1, value:1});
				$('.slider').hide();
				try {
					// Fix up for prefixing
					window.AudioContext = window.AudioContext
							      ||window.webkitAudioContext;
					 audioContext = new AudioContext();
				}
				 catch(e) {
					alert('Web Audio API is not supported in this browser');
				}

				initWaveShaper();
				
				ctxt.strokeRect(0, 0, canvas.width, canvas.height);	
			}
			
			// load sound from input mp3
			function loadSound(file) {
				var reader = new FileReader();
				reader.onload = function(e) {
					var buff = e.target.result;
					playSound(buff);
				}				
				
				reader.readAsArrayBuffer(file);

				// init white noise
			}


			function hexStringToRGBA(color, r) {
				var hexstring = "0x" + color.substring(1);
				var numval = parseInt(hexstring, 16);		
				var red = (numval >> 16);
				var green = (numval >> 8) & 0x0000FF;
				var blue = numval & 0x0000FF;
				var rgba = "rgba(" + red + " , " + green + 
							" , " + blue  + "," + (30-r)/30 * 0.9 + ")";
			
				return rgba;
			}

			function createWSCurve(amount, numsamples) {
				var curve = new Float32Array(numsamples);
				if (amount >=0 && amount < 1) {
					var k = 10 * amount / (1 - amount);
					for (var i = 0; i < numsamples; i++) {
						var x = (i - 0) * (1 - (-1)) / (numsamples - 0) + (-1);
						curve[i] = (1 + k) * x / (1+ k * Math.abs(x));					

					}
				}

				return curve;
			}


			function initWaveShaper() {
				wavedistort = 0;
				waveshaper = audioContext.createWaveShaper();
			}
	
			function analyzeSound() {
				requestAnimationFrame(analyzeSound);
				if (frame % 10 != 0 && colormode != ColorMode.MONOTONE) {
					frame ++;
					return;
				}
	
				if (frame % framespeed != 0) {
					frame++;
					return;
				}
				
				var timeDomain = new Uint8Array(analyser.frequencyBinCount);
				analyser.getByteTimeDomainData(timeDomain);
			
				var max = 0;
			/*	for (var i = 0; i < timeDomain.length; i++) {
					if (timeDomain[i] > max) {
						max = timeDomain[i];
					}
				}

				console.log('max = ' + max);*/
	
				var freqDomain = new Float32Array(analyser.frequencyBinCount);

				analyser.getFloatFrequencyData(freqDomain);
				ctxt.clearRect(0,0, WIDTH, HEIGHT);
				for (var freq = 0; freq < freqDomain.length; freq++) {
					var x, y, r;
					var amp = freqDomain[freq];

					// interpolate between spiral and reverse spiral
					r = Math.abs(Math.pow(amp/SAMPLE_MAX, 2)) * 50; 

					if (interp <= 1) {	
						var sx = 0.2 * freq * Math.cos(freq); 
						var sy = 0.2 * freq * Math.sin(freq); 
						
						var rev = 1024 - freq;
						var rx =  0.3 * rev * Math.cos(rev);
						var ry =  0.3 * rev * Math.sin(rev);

						x = (1 - interp) * sx + interp * rx;
						y = (1 - interp) * sy + interp * ry;
						
						if (interp < 0.5) {
							gridmode = GridMode.SPIRAL;
							reversed = false;
						}
						else {
							gridmode = GridMode.REVERSESPIRAL;
							reversed = true;
						}
					}
					else if (interp <= 2) { // rev spiral and epicycloid
						var rev = 1024 - freq;
						var rx =  0.3 * rev * Math.cos(rev);
						var ry =  0.3 * rev * Math.sin(rev);

						var a = freq/1024 * 200;
						var b = a / 7;
						var ex = (a + b) * Math.cos(freq) - b * Math.cos((a / b + 1)*freq); 
						var ey = (a + b) * Math.sin(freq) - b * Math.sin((a / b + 1)*freq);

						var i = interp - 1;
						x = (1 - i) * rx + i * ex;
						y = (1 - i) * ry + i * ey;
						
						if (interp < 1.5) {
							gridmode = GridMode.REVERSESPIRAL;
							reversed = true;
						}
						else {
							gridmode = GridMode.EPICYCLOID;
							reversed = false;
						}
 					} 
					else if (interp <= 3) { // epicycloid and reverse epi
						var rev = 1024 - freq;
						var a = freq/1024 * 200;
						var b = a / 7;
						var ex = (a + b) * Math.cos(freq) - b * Math.cos((a / b + 1)*freq); 
						var ey = (a + b) * Math.sin(freq) - b * Math.sin((a / b + 1)*freq);

						var rex = (a + b) * Math.cos(rev) - b * Math.cos((a / b + 1)*rev); 
						var rey = (a + b) * Math.sin(rev) - b * Math.sin((a / b + 1)*rev);

						var i = interp - 2;
						x = (1 - i) * ex + i * rex;
						y = (1 - i) * ey + i * rey;

						if (interp < 2.5) {
							gridmode = GridMode.EPICYCLOID;
							reversed = false;
						}
						else {
							gridmode = GridMode.REVERSEEPIC;
							reversed = true;
						}
					} 
					else { // rev epi and hyp
						var a = freq/1024 * 200;
						var b = a / 7;
						var rev = 1024 -freq;
						var rex = (a + b) * Math.cos(rev) - b * Math.cos((a / b + 1)*rev); 
						var rey = (a + b) * Math.sin(rev) - b * Math.sin((a / b + 1)*rev);

						var c = 150;
						var hx = (a - b) * Math.cos(freq) - c * Math.cos((a / b - 1)*freq);
						var hy = (a - b) * Math.sin(freq) - c * Math.sin((a / b - 1)*freq);

						var i = interp - 3;
						x = (1 - i) * rex + i * hx;
						y = (1 - i) * rey + i * hy;

						if (interp < 3.5) {
							gridmode = GridMode.REVERSEEPIC;
							reversed = true;
						}
						else {
							gridmode = GridMode.HYPOTROCHOID;
							reversed = false;
						}
					} 
	
					x = x * spacing + WIDTH/2;
					y = y * spacing + HEIGHT/2;
					
					/*switch(gridmode) {
						case GridMode.RIGID:
							x = Math.floor(freq % GRID_WIDTH) * WIDTH/GRID_WIDTH + 10;
							y = Math.floor(freq / GRID_WIDTH) * HEIGHT/GRID_HEIGHT + 10;
							r = Math.abs(amp/SAMPLE_MAX) * 30;	
						break;
						case GridMode.CONCENTRIC:
							x = WIDTH/2;
							y = HEIGHT/2;
							r = Math.abs(Math.pow(amp/SAMPLE_MAX, 2)) * WIDTH/4; 
						break;
						case GridMode.RANDOM:
							x = Math.random() * WIDTH;
							y = Math.random() * HEIGHT;
							r = Math.abs(Math.pow(amp/SAMPLE_MAX, 2)) * 50; 
						break;
						case GridMode.SPIRAL:
							x = 0.2 * spacing * freq * Math.cos(freq) + WIDTH/2; 
							y =  0.2 * spacing * freq * Math.sin(freq) + HEIGHT/2;
							r = Math.abs(Math.pow(amp/SAMPLE_MAX, 2)) * 50; 
						break;
						case GridMode.REVERSESPIRAL:
							var rev = 1024 - freq;
							x = 0.3 * rev * Math.cos(rev) + WIDTH/2; 
							y =  0.3 * rev * Math.sin(rev) + HEIGHT/2;
							r = Math.abs(Math.pow(amp/SAMPLE_MAX, 2)) * 50; 
						break;
						case GridMode.BUTTERFLY:
							var cosf = Math.cos(freq);
							var sinf12 = Math.sin(freq/12);
							var ecosf = Math.pow(Math.E, cosf);
							var mult = (ecosf - 2 * Math.cos(4 * freq) - Math.pow(sinf12, 5));

							x = 70 * Math.sin(freq) * mult + WIDTH/2;
							y = 50 * Math.cos(freq) * mult + HEIGHT/2;
							r = Math.abs(Math.pow(amp/SAMPLE_MAX, 2)) * 50; 
						break;
						case GridMode.ASTROID:
							x = 300 *(freq/1024)* Math.pow(Math.cos(freq), 3) + WIDTH/2 ;
							y = 240 *(freq/1024)* Math.pow(Math.sin(freq), 3) + HEIGHT/2;
							r = Math.abs(Math.pow(amp/SAMPLE_MAX, 2)) * 50; 
						break;
						case GridMode.EPICYCLOID:
							var a = freq/1024 * 200;
							var rev = 1024 - freq;
							var b = a/7; 
							var revx =  (a + b) * Math.cos(rev) - b * Math.cos((a / b + 1)*rev);
							var revy =  (a + b) * Math.sin(rev) - b * Math.sin((a / b + 1)*rev);
							
							x = (1- interp) * (a + b) * Math.cos(freq) - b * Math.cos((a / b + 1)*freq) +
							    interp * revx + WIDTH/2;
							y = (1- interp) * (a + b) * Math.sin(freq) - b * Math.sin((a / b + 1)*freq) + 
							    interp * revy + HEIGHT/2;
							r = Math.abs(Math.pow(amp/SAMPLE_MAX, 2)) * 50; 
						break;
						case GridMode.REVERSEEPIC:
							var rev = 1024 - freq;
							var a = rev/1024 * 200;
							var b = a/7; 
							var c = 100;
							x = (a + b) * Math.cos(rev) - b * Math.cos((a / b + 1)*rev) + WIDTH/2;
							y = (a + b) * Math.sin(rev) - b * Math.sin((a / b + 1)*rev) + HEIGHT/2;
							r = Math.abs(Math.pow(amp/SAMPLE_MAX, 2)) * 50; 
						break;
						case GridMode.HYPOTROCHOID:
							var a = freq/1024 * 200;
							var b = a/7; 
							var c = 150;
							x = (a - b) * Math.cos(freq) - c * Math.cos((a / b - 1)*freq) + WIDTH/2;
							y = (a - b) * Math.sin(freq) - c * Math.sin((a / b - 1)*freq) + HEIGHT/2;
							r = Math.abs(Math.pow(amp/SAMPLE_MAX, 2)) * 50; 
						break;
						default:
							x = Math.floor(freq % GRID_WIDTH) * WIDTH/GRID_WIDTH + 10;
							y = Math.floor(freq / GRID_WIDTH) * HEIGHT/GRID_HEIGHT + 10;
							r = Math.abs(amp/SAMPLE_MAX) * 30;	
					}*/

					
					var lastamp = lastAmps[freq];
					var delta = (lastamp - amp);
					
					switch (colormode) {
						case ColorMode.MONOCHROME:
							ctxt.fillStyle = 'rgba(0, 255, 0,' + r/30 * 0.9 + ')';
						break;					
						case ColorMode.TWOTONE:
							if (delta > 1) {
								ctxt.fillStyle = 'rgba(0 ,0, 255,' + r/30 * 0.9 + ')';
							}
							else {
								ctxt.fillStyle = 'rgba(0, 255, 0,' + r/30 * 0.9 + ')';
							}
						break;					
						case ColorMode.THREETONE:
							if (delta > 1) {
								ctxt.fillStyle = hexStringToRGBA(color1, r);
							}
							else if (delta < -1) {
								ctxt.fillStyle = hexStringToRGBA(color2, r);
							}
							else {
								ctxt.fillStyle = hexStringToRGBA(color3, r);
							}
						break;					
						case ColorMode.GRADIENT:
							ctxt.fillStyle = 'rgba(' + + ' , ' +  +  ' , ' + +  ' , ' + r/30 * 0.9 + ')';
						break;
						case ColorMode.RANDOM:
							var red = Math.random() * 255;
							var green= Math.random() * 255;
							var blue = Math.random() * 255;
							var a = r/30 * 0.9;	
							ctxt.fillStyle = 'rgba('+ red + ','+ green + ',' + blue + ',' + r/30 * 0.9 + ')';
							break;	
						default:
							ctxt.fillStyle = 'rgba(0, 255, 0,' + r/30 * 0.9 + ')';
					}

					switch (shapemode) {
						case ShapeMode.CIRCLE:
							ctxt.beginPath();
							ctxt.arc(x, y, r, 0, Math.PI * 2);
							ctxt.fill();
						break;	
						case ShapeMode.SQUARE:
							ctxt.beginPath();
							ctxt.rotate(frame % 2 * Math.PI);
							ctxt.rect(x - r, y-r, r * 2, r * 2);
							ctxt.fill();
						break;	
						case ShapeMode.SKEW:
							ctxt.beginPath();
							ctxt.arc(x, y, r, 0, Math.PI * 2);
							ctxt.fill();
						break;	
						default:
							ctxt.beginPath();
							ctxt.arc(x, y, r, 0, Math.PI * 2);
							ctxt.fill();
					}
				}

				drawLines();
				drawFilters();			
	
				lastAmps = freqDomain;
				frame++;
			}

			function drawLines() {
				ctxt.beginPath();
				ctxt.strokeStyle = "#000000";
				for (var i = 0; i < noiseLines.length; i++) {

					if (noiseLines[i].length > 0 ) { 
						var start = noiseLines[i][0];
						ctxt.moveTo(start.x, start.y);	
						
						for (var j = 1; j < noiseLines[i].length; j++) {
							var next = noiseLines[i][j];
							ctxt.lineTo(next.x, next.y);
						}	
					
						ctxt.stroke();
					}

				}

				ctxt.strokeStyle = "#FFFFFF";
			}


			function drawFilters() {
				ctxt.fillStyle = 'rgba(255, 255, 255, 0.9)'; 
				for (var i = 0; i < filterShapes.length; i++) {
					// draw the filter
					var nextfilter = filterShapes[i];
					ctxt.beginPath();
					ctxt.arc(nextfilter.x, nextfilter.y, nextfilter.r, 0, Math.PI * 2);
					ctxt.fill();
				} // end for
			}

			// play sound from ArrayBuffer
			function playSound(buffer) {
				// disconnect if there is already a song uploaded
				if (audioSource) {
					audioSource.stop();
					audioSource.disconnect(0);
				}
				
				audioSource = audioContext.createBufferSource();
				gainnode = audioContext.createGain();
				
				try {
					audioSource.buffer = audioContext.createBuffer(buffer,false);
				} catch (e) {
					console.log("error reading sound file");
					return;
				}				
				
				$('h1').hide();
				$('#dragDiv').hide();
				$('#canvas').show();
				//$('#backBtn').show();
				$('#main').css("background-color", "white");
				sceneDisplayed = true;
				$('.slider').show();
				$('#controls').hide();	
				console.log('colormode = ' + colormode);
				console.log('gridmode = ' + gridmode);
				// set up the AudioAnalserNode
				analyser = audioContext.createAnalyser();
				audioSource.connect(analyser);

				lastAmps = new Float32Array(analyser.frequencyBinCount);

//				analyser.connect(audioContext.destination);
//				audioSource.connect(audioContext.destination);
				
				analyser.connect(audioContext.destination);
				audioSource.connect(analyser);		 
				audioSource.start(0);
				analyzeSound();
			}		
			
			function allowDrop(ev) {
//				console.log('registered drag');
				ev.preventDefault();
			}
			
			function drop(ev) {
				ev.preventDefault();
				var data = ev.dataTransfer.files[0];	
				if (data) {
					loadSound(data);
				}
			}
		
			function applyEffects() {
				audioSource.disconnect(0);
				audioSource.playbackRate.value = 1 / spacing;
				waveshaper.connect(audioContext.destination);
				audioSource.connect(waveshaper);			

				gainnode.connect(audioContext.destination);
				audioSource.connect(gainnode);	

				var source = audioSource; // save state
					
				// add filters
				for (var i = 0; i < filters.length; i++) {
					var filter = filters[i];
					audioSource.connect(filter);
					audioSource = filter;	
				}

				analyser.connect(audioContext.destination);
				audioSource.connect(analyser);
			 	audioSource = source; // restore state
			}

			function addNoise() {
				var bufferSize = 2 * audioContext.sampleRate,
   	 			noiseBuffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate),
    				output = noiseBuffer.getChannelData(0);
				for (var i = 0; i < bufferSize; i++) {
				    output[i] = Math.random() * 2 - 1;
				}

				whiteNoise = audioContext.createBufferSource();
				whiteNoise.loop = true;
				whiteNoise.buffer = noiseBuffer;
			}
		
			function addFilter(newfilter) {
				if (newfilter.r > 0) {	
					var filter = audioContext.createBiquadFilter();
					filter.type = filter.LOWPASS;
					var freq;
						
					if (reversed == false)  {
						var a = (newfilter.x - WIDTH/2)/(0.2 * spacing); // freq * cos(freq)
						var b = (newfilter.y - HEIGHT/2)/(0.2 * spacing); // freq * sin(freq)
						var x = newfilter.x;
						var y = newfilter.y;
						var f = Math.atan(b/a);
					
						if (a < 0 && Math.cos(f) > 0) {
							f += Math.PI;
						}

						freq = Math.min(1024, a / Math.cos(f));	
						}
					else {
						var a = (newfilter.x - WIDTH/2)/(0.3 * spacing);
						var b = (newfilter.y - HEIGHT/2)/(0.3 * spacing);
						var rf = Math.atan(b/a);
						
						if (a < 0 && Math.cos(rf) > 0) {
							rf += Math.PI;
						}	

						var rev = Math.min(1024, a/Math.cos(rf));
						freq = 1024 - rev;
					}
	
					filter.frequency.value = freq;
					filter.Q.value = 1 / newfilter.r;
				//	filter.Q.value = 0.0001;
					filters.push(filter);
					console.log("added filter with value = " + freq + " and Q = " + filter.Q.value);
					applyEffects();
				}
			}
		
			function wavedistortionChange(event, ui) {
				interp = ui.value;
				wavedistort = ui.value /4;

				if (wavedistort >= 0.99) {
					wavedistort = 0.985;
				}
	
				waveshaper.curve = createWSCurve(wavedistort, audioContext.sampleRate);
				applyEffects();
			}

			function playbackspeedChange(event, ui) { 
				spacing = Math.max(0.1, ui.value);
				applyEffects();
				// audioSource.playbackRate.value = 1 / spacing;
			}

			$(document).ready(function() {
				cwheel = new ColorWheel(100);
				init();


			$(".colormode").change(function () {
				colormode = parseInt(this.value);
				console.log('colormode = ' + colormode);
			});

			$('.gridmode').change(function () {
				gridmode = parseInt(this.value);
				console.log('gridmode = ' + gridmode);
			});
			$('.shapemode').change(function () {
				shapemode = parseInt(this.value);
				console.log('shapemode = ' + shapemode);
			});

			$("#menucontainer").mouseover(function (event){
				if (sceneDisplayed && !drawing && !drawingFilter) {
					$("#menu").show();
				}	
			});

			$("#menucontainer").mouseout(function (event) {
				$("#menu").hide();
			});

			$("#penimage").click(function(){
				switch(drawmode){
					case DrawMode.PEN:
						this.src = "images/pen.png"
						drawmode = DrawMode.NONE;
					break;
					case DrawMode.NONE:
						this.src = "images/penselected.png"
						drawmode = DrawMode.PEN;
					break;
					case DrawMode.FILTER:
						var filt = $($("#filterimage"))[0];
						filt.src = "images/filter.png";

						this.src = "images/penselected.png"
						drawmode = DrawMode.PEN;
					default:
				}
			});

			$("#filterimage").click(function(){
				switch(drawmode){
					case DrawMode.FILTER:
						this.src = "images/filter.png"
						drawmode = DrawMode.NONE;
					break;
					case DrawMode.NONE:
						this.src = "images/filterselected.png"
						drawmode = DrawMode.FILTER;
					break;
					case DrawMode.PEN:
						var pen = $($("#penimage"))[0];
						pen.src = "images/pen.png";
						this.src = "images/filterselected.png"
						drawmode = DrawMode.FILTER;
					default:
				}
			});
			$("#canvas").mousedown(function (event) {
				mousedownx = event.pageX;
				mousedowny = event.pageY;

				if (drawmode == DrawMode.PEN) {
					drawing = true;
					var nextline = [];
					noiseLines.push(nextline);					
	
					addNoise();
					whiteNoise.start(0);
					whiteNoise.connect(audioContext.destination);		
				}

				else if (drawmode == DrawMode.FILTER){
					drawingFilter = true;
					var filter = {x: 0, y:0, r:0};

					var offsetX = $(this).offset().left;
					var offsetY = $(this).offset().top;
						
					filter.x = event.pageX - offsetX;
					filter.y = event.pageY - offsetY;	
					filterShapes.push(filter);
				}

			});

			$("canvas").mousemove(function (event) {
				var offsetX = $(this).offset().left;
				var offsetY = $(this).offset().top;

				if (drawing && drawmode == DrawMode.PEN) {
					var line = noiseLines[noiseLines.length - 1];
					
					var nextpt = {x: event.pageX - offsetX, y:event.pageY - offsetY};
					line.push(nextpt);
				}

				else if (drawingFilter && drawmode == DrawMode.FILTER) {
					var filter = filterShapes[filterShapes.length - 1];
					var r = Math.max(0, event.pageX - offsetX - filter.x);
					filter.r = r;		
				}
			});	

			
			$("#canvas").mouseup(function (event) {
				var dist = Math.sqrt(Math.pow(event.pageX - mousedownx, 2) + Math.pow(event.pageY - mousedowny, 2));
				console.log("dist = " + dist);
			
				if (dist < 0.001) {
					if (drawmode == DrawMode.FILTER) {
						filterShapes.splice(filterShapes.length - 1, 1); 
						drawingFilter = false;
					}

					else if (drawmode == DrawMode.PEN) {
						noiseLines.splice(noiseLines.length - 1, 1); 
						whiteNoise.stop();
						drawing = false;
					}

					var offsetX = $(this).offset().left;
					var offsetY = $(this).offset().top;

					for (var i = 0; i < filterShapes.length; i++) {
						var nextfilter = filterShapes[i];
						var xc = nextfilter.x;
						var yc = nextfilter.y;
						var x = event.pageX - offsetX;
						var y = event.pageY - offsetY;

						if (Math.sqrt(Math.pow(xc - x, 2) + Math.pow(yc - y, 2)) < nextfilter.r) {
							filterShapes.splice(i, 1); // remove this filter
							console.log("filter shapes after click ");
							console.log(filterShapes);
							console.log('removed filter shape at position ' + i);
							filters.splice(i, 1);
							console.log('removed filter at position ' + i);
							applyEffects();
							break;
						}
					}
				}

				else if (drawmode == DrawMode.PEN) {
					drawing = false;
	
					if (noiseLines.length > 0) {
						var newline = noiseLines[noiseLines.length - 1];
						noiseLines.splice(noiseLines.length -1, 1);
						whiteNoise.stop();
					}
					
				}
				else if (drawmode == DrawMode.FILTER) {
					drawingFilter = false;

					// add a sound filter
					if (filterShapes.length > 0) {
					//	console.log("filtershapes after mouseup" );
					//	console.log(filterShapes);
						var newfilter = filterShapes[filterShapes.length - 1];
						addFilter(newfilter);	
					}

					deletedFilter = false;
				}
				
			})
	
			$(".color").spectrum({showInput:true});
			
			$("#color1").change(function() {
				color1 = this.value;
			});

			$("#color2").change(function() {
				color2 = this.value;
			});

			$("#color3").change(function() {
				color3 = this.value;
			});

			$("#backBtn").click(function() {
				window.location.reload();
			});

			});	


		</script>
	</head>

	<body>
		<div id="main">
	<!--	<h1>SOUND SCENE</h1> -->
		<img id="colorwheel" src="images/colorwheel.png"></img>	
		<div id="dragDiv" class="row" ondragover="allowDrop(event)" ondrop="drop(event)">
			<image id="playIm" src="images/draganddroppurple.png"/>
		</div>
		
		<div class="container">
		<div class= "row">
				<canvas id="canvas"></canvas>
				<button type = "back" id="backBtn">back</button>
		</div>
		<div id="menucontainer" class = "container">
			<div id="menu" class="row">
				<div class="col-md-2">
					<div id="wavedistortion" class="slider" ></div>
					<div id="playbackspeed" class="slider" ></div>
				</div>
				<image id="penimage" src="images/pen.png"></image> <image id="filterimage" src="images/filter.png"></image>
				<!--<input id="color1"  class="color" type="color" name = "color" value="#7355d7"/>
				<input  id="color2" class="color" type="color" name = "color2" value="#FFFF00"/>
				<input  id="color3" class="color" type="color" name = "color3" value="#00FF00"/>-->
				<canvas id="wheelcanvas"></canvas>
				<div class="col-md-2">
				</div>
			</div>
		</div>
		</div>
		<div id='controls'>
		<p>//TEMPORARY CONTROLS</p>
		<p>Shape Mode: </p>
		<input type='radio' class='shapemode' name='shapemode' value='0'> CIRCLE </input>
		<br></br>
		<input type='radio' class='shapemode' name='shapemode' value='1'> SQUARE </input>
		<br></br>
		<p>Color Mode: </p>
		<input type='radio' class='colormode' name='colormode' value='0'> MONOCHROME </input>
		<br></br>
		<input type='radio' class='colormode' name='colormode' value='1'> TWOTONE </input>
		<br></br>
		<input type='radio' class='colormode'  name='colormode' value='2'> THREETONE </input>

		<p>Grid Mode: </p>
		<input type='radio'  class='gridmode' name='gridmode' value='0'> RIGID </input>
		<br></br>
		<input type='radio'  class='gridmode'  name='gridmode' value='1'> CONCENTRIC </input>
		<br></br>
		<input type='radio'  class='gridmode'   name='gridmode' value='2'> RANDOM </input>
		<br></br>
		<input type='radio'  class='gridmode'  name='gridmode' value='3'> SPIRAL </input>
		<br></br>
		<input type='radio'  class='gridmode'  name='gridmode' value='4'> REVERSE SPIRAL </input>
		<br></br>
		<input type='radio'  class='gridmode'   name='gridmode' value='5'> BUTTERFLY </input>
		<br></br>
		<input type='radio'  class='gridmode'  name='gridmode' value='6'> ASTROID </input>
		<br></br>
		<input type='radio'  class='gridmode'  name='gridmode' value='7'> EPICYCLOID </input>
		<br></br>
		<input type='radio'  class='gridmode'   name='gridmode' value='8'> REVERSE EPICYCLOID </input>
		<br></br>
		<input type='radio'  class='gridmode'  name='gridmode' value='9'> HYPOTROCHOID </input>
		<br></br>
		</div>
	</div>
</body>
</html>
